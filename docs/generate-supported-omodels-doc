#!/usr/bin/env python3
import logging

import os
import sys
sys.path.insert(0, os.path.abspath(os.path.join('..')))

import coloredlogs
import argparse as arg
from jinja2 import Template

from pyavcontrol import DeviceModelLibrary

LOG = logging.getLogger(__name__)
coloredlogs.install(level="DEBUG")

DEFAULT_FILE='source/supported.md'

TEMPLATE = Template('''
## Supported Equipment

*This is autogenerated from pyavcontrol's DeviceModel library (using build-supported-models-doc).*
{% set manufacturer = namespace(value='') %}
{% for model in models %}{% if model.manufacturer != manufacturer.value %}{% set manufacturer.value = model.manufacturer %}
### {{ model.manufacturer }}

| Model             | Protocol           |  Tested | Notes             |
| :---------------- | :----------------: | :-----: | :---------------- |
{% endif %}| {{ model.model_name }} | {{ model.model_id }} | model.tested | model.notes |
{% endfor %}
''')

def parse_args():
    p = arg.ArgumentParser(description="Generate SUPPORTED.md using current pyavcontrol model library")
    p.add_argument(
        "--output", default=DEFAULT_FILE, help=f"Markdown output file (default={DEFAULT_FILE})"
    )
    p.add_argument(
        "--library", help="library directories"
    )
    p.add_argument("-d", "--debug", action="store_true", help="verbose logging")
    return p.parse_args()

def main():
    args = parse_args()

    # if custom library directories have been specified, only output models found within
    if args.library:
        dirs = args.library.split(',')
        library = DeviceModelLibrary.create(library_dirs=dirs)
    else:
        library = DeviceModelLibrary.create()

    supported_models = library.supported_models()

    # sort by manufacturer and model name
    sorted_models = sorted(supported_models, key=lambda k: (k.manufacturer, k.model_name))

    LOG.info(f"Saving the output to {args.output}")
    with open(args.output , "w") as f:
        f.write(TEMPLATE.render(models=sorted_models))

if __name__ == "__main__":
    main()
